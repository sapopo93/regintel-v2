/**
 * Malware Scan Worker
 *
 * Scans uploaded blobs for malware using ClamAV.
 * Updates EvidenceBlob scan status in database after scanning.
 */

import { Worker, type Job } from 'bullmq';
import { PrismaClient } from '@prisma/client';
import {
  QUEUE_NAMES,
  createWorkerConnection,
  type MalwareScanJobData,
  type MalwareScanJobResult,
} from '@regintel/queue';
import { getClamAVClient, getClamAVHealth } from '../integrations/clamav';
import { readBlob, quarantineBlob as quarantineBlobFromStorage } from '../integrations/blob-storage';
import { config } from '../config';

const prisma = new PrismaClient();

/**
 * Update EvidenceBlob scan status in database
 */
async function updateBlobScanStatus(
  blobHash: string,
  status: 'PENDING' | 'CLEAN' | 'INFECTED' | 'ERROR',
  scanEngine: string,
  threat?: string,
  quarantined?: boolean
): Promise<void> {
  try {
    await prisma.evidenceBlob.update({
      where: { contentHash: blobHash },
      data: {
        scanStatus: status,
        scannedAt: new Date(),
        scanEngine,
        scanThreat: threat ?? null,
        scanResult: status,
        quarantined: quarantined ?? false,
      },
    });
  } catch (error) {
    // Log but don't fail the job - scan result is still valid
    console.error(`[MalwareScan] Failed to update blob status in DB: ${blobHash}`, error);
  }
}

/**
 * Process malware scan job
 */
async function processMalwareScan(
  job: Job<MalwareScanJobData>
): Promise<MalwareScanJobResult> {
  const { blobHash } = job.data;
  const startTime = Date.now();

  console.log(`[MalwareScan] Processing job ${job.id} for blob ${blobHash}`);

  // Check if ClamAV is available
  const health = await getClamAVHealth();

  if (!health.enabled) {
    console.warn('[MalwareScan] ClamAV disabled, returning stub result');

    // In development/test, return CLEAN as stub
    await updateBlobScanStatus(blobHash, 'CLEAN', 'stub-scanner-v1');
    return {
      blobHash,
      status: 'CLEAN',
      scanEngine: 'stub-scanner-v1',
      scannedAt: new Date().toISOString(),
    };
  }

  if (!health.available) {
    console.error('[MalwareScan] ClamAV unavailable while enabled');
    await updateBlobScanStatus(blobHash, 'ERROR', 'clamav');
    return {
      blobHash,
      status: 'ERROR',
      scanEngine: 'clamav',
      scannedAt: new Date().toISOString(),
    };
  }

  try {
    // Get blob content (this would come from blob storage)
    // For now, we'll need the blob to be passed or fetched
    const blobContent = await readBlob(blobHash);

    if (!blobContent) {
      await updateBlobScanStatus(blobHash, 'ERROR', 'clamav');
      return {
        blobHash,
        status: 'ERROR',
        scanEngine: 'clamav',
        scannedAt: new Date().toISOString(),
      };
    }

    // Scan with ClamAV
    const client = getClamAVClient();
    const result = await client.scanBuffer(blobContent);

    // Handle infected files
    if (result.status === 'INFECTED') {
      console.warn(`[MalwareScan] Infected file detected: ${blobHash} - ${result.threat}`);

      // Quarantine the blob in storage
      await quarantineBlobFromStorage(blobHash);

      // Update database with infected status
      await updateBlobScanStatus(blobHash, 'INFECTED', 'clamav', result.threat, true);

      return {
        blobHash,
        status: 'INFECTED',
        threat: result.threat,
        scanEngine: 'clamav',
        scannedAt: new Date().toISOString(),
        quarantined: true,
      };
    }

    console.log(`[MalwareScan] Clean file: ${blobHash}`);

    // Update database with clean status
    await updateBlobScanStatus(blobHash, 'CLEAN', 'clamav');

    return {
      blobHash,
      status: 'CLEAN',
      scanEngine: 'clamav',
      scannedAt: new Date().toISOString(),
    };
  } catch (error) {
    console.error(`[MalwareScan] Error scanning ${blobHash}:`, error);

    // Update database with error status
    await updateBlobScanStatus(blobHash, 'ERROR', 'clamav');

    return {
      blobHash,
      status: 'ERROR',
      scanEngine: 'clamav',
      scannedAt: new Date().toISOString(),
    };
  }
}

/**
 * Create and start malware scan worker
 */
export function createMalwareScanWorker(): Worker<MalwareScanJobData, MalwareScanJobResult> {
  const connection = createWorkerConnection(QUEUE_NAMES.MALWARE_SCAN);

  const worker = new Worker<MalwareScanJobData, MalwareScanJobResult>(
    QUEUE_NAMES.MALWARE_SCAN,
    processMalwareScan,
    {
      connection,
      concurrency: config.worker.concurrency.malwareScan,
    }
  );

  worker.on('completed', (job, result) => {
    console.log(`[MalwareScan] Job ${job.id} completed: ${result.status}`);
  });

  worker.on('failed', (job, error) => {
    console.error(`[MalwareScan] Job ${job?.id} failed:`, error.message);
  });

  return worker;
}
